/**
 * QUICK SORT
 * Алгоритм
 * 1. Выбрать опорный элемент
 * 2. Разделить массив на два подмассива: элементы больше и меньше опорного.
 * 3. Рекурсивно применить сортировку к двум подмассивам.
 * --- -- - -
 * Сложность QUICK SORT
 * В худшем случае будет О(n^2).
 * Сложность будет зависит от того, какой элемент мы выберем в качестве опорного.
 */

/**
 * Выбираем опорный элемент из массива. Может быть любой.
 *
 * Проходим по массиву и делим его на две части:
 * в первый массив кладем все элементы котор. меньше опорного,
 * во втрой - элементы, котор больше опорного.
 *
 * Применяем имеющийся алгоритм для уже сформированного подмассива.
 *
 * Повторяем до тех пор, пока не наступит базовый случай,
 * при котором не нужно ничего сортировать.
 */

const test = [3, 1, 7, 2, 11, 4, 12, 5, 0];
const testA = [2];

/// Вариант 1 - Реализация алгоритма с созданием подмассива
const quickSort = (array) => {
  /// массив состоит из одного элемента
  /// это базовый случай
  if (array.length < 2) {
    return array;
  }

  /// @#! const pivot = array[0]; - не лучший выбор, так как будет увеличиваться сложность O-большое

  /// для опорного элемента берем элемент из середины массива
  const pivotIndex = Math.floor(array.length / 2);

  /// pivot - опорный элемент
  const pivot = array[pivotIndex];

  /// в less будем добавлять элементы, значение которых будут меньше значения опорного элемента pivot
  const less = [];

  /// в greater будем добавлять элементы, значение которых будут больше значения опорного элемента pivot
  const greater = [];

  /// i = 1 - т.к. для опорного элемента pivot выбрали первый элемент массива (@#!)
  // @# for (let i = 1; i < array.length; i++) {

  for (let i = 0; i < array.length; i++) {
    /// если идем по @#!, то этот if не нужен
    if (i === pivotIndex) {
      continue;
    }

    if (array[i] <= pivot) {
      less.push(array[i]);
    } else {
      greater.push(array[i]);
    }
  }

  // console.log(less, pivot, greater);

  /**
   * Сначала завершится рекурсия по quickSort(less)
   * pivot - после первого прохода станет по середине
   * в конце закончатся рекурсии по quickSort(greater)
   */
  return [...quickSort(less), pivot, ...quickSort(greater)];
};

console.log('res:', quickSort(test)); /// 0 1 2 3 4 5 7 11 12

/// Вариант 2 - Реализация алгоритма быстрой сортировки с перестановкой элементов
